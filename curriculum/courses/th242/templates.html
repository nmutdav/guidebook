---
layout: default
title: Templates
permalink: /curriculum/th242/templates
---
<main>
    <body>
        <h1>{{ page.title }}</h1>
<h2>Rainstorm animation</h2>
<pre>
    int numDrops = 100; // Number of raindrops
    Raindrop[] drops = new Raindrop[numDrops];
    
    void setup() {
      size(800, 600);
      background(0);
      
      // Initialize raindrops
      for (int i = 0; i < numDrops; i++) {
        drops[i] = new Raindrop(random(width), random(-height, 0));
      }
    }
    
    void draw() {
      background(0, 50); // Semi-transparent background to create a trail effect
      
      // Update and display each raindrop
      for (int i = 0; i < numDrops; i++) {
        drops[i].update();
        drops[i].display();
      }
    }
    
    // Raindrop class
    class Raindrop {
      float x, y;
      float speed;
      
      Raindrop(float x, float y) {
        this.x = x;
        this.y = y;
        this.speed = random(2, 5);
      }
      
      void update() {
        y += speed;
        // Reset drop to the top if it goes off screen
        if (y > height) {
          y = random(-50, -10);
          x = random(width);
          speed = random(2, 5);
        }
      }
      
      void display() {
        stroke(138, 43, 226); // Color of raindrop (blueish)
        strokeWeight(2);
        line(x, y, x, y + 10);
      }
    }
</pre>
<h2> Simple Sound Effect Player</h2>
<pre>
import ddf.minim.*; // Import the Minim library

Minim minim; // The Minim object
AudioPlayer player; // The audio player object

void setup() {
  size(400, 200);
  minim = new Minim(this); // Initialize Minim
  
  // Load the sound file (make sure the file is in the 'data' folder)
  player = minim.loadFile("sound.mp3"); // Change the file name if needed
  
  background(0); // Set background to black
  fill(255); // Set text color to white
  textAlign(CENTER, CENTER);
  textSize(20);
  text("Press any key to play sound", width / 2, height / 2);
}
</pre>

<h2>Interactive Gradient</h2>

<pre>
    void setup() {
        size(800, 600);
        noLoop(); // Prevent continuous redrawing
      }
      
      void draw() {
        // Map mouse position to gradient colors
        float red1 = map(mouseX, 0, width, 0, 255);
        float green1 = map(mouseY, 0, height, 0, 255);
        float blue1 = map(mouseX + mouseY, 0, width + height, 0, 255);
        
        float red2 = map(mouseX, 0, width, 255, 0);
        float green2 = map(mouseY, 0, height, 255, 0);
        float blue2 = map(mouseX + mouseY, 0, width + height, 255, 0);
      
        // Draw the gradient background
        for (int i = 0; i <= height; i++) {
          float inter = map(i, 0, height, 0, 1);
          float r = lerp(red1, red2, inter);
          float g = lerp(green1, green2, inter);
          float b = lerp(blue1, blue2, inter);
          stroke(r, g, b);
          line(0, i, width, i);
        }
      }
      
      void mouseMoved() {
        redraw(); // Redraw the background when the mouse is moved
      }
</pre>

<h2> Interactive Field of Grains</h2>
<pre>
  int numGrains = 500; // Number of grains in the field
  Grain[] grains;
  
  void setup() {
    size(800, 600);
    noStroke();
    colorMode(HSB, 255); // Use HSB color mode for color variations
    
    // Initialize the grains
    grains = new Grain[numGrains];
    for (int i = 0; i < numGrains; i++) {
      grains[i] = new Grain(random(width), random(height));
    }
  }
  
  void draw() {
    background(0, 10); // Add a slight fade effect
    
    // Update and display each grain
    for (Grain grain : grains) {
      grain.update();
      grain.display();
    }
  }
  
  class Grain {
    float x, y; // Position of the grain
    float xSpeed, ySpeed; // Speed of the grain
    float radius; // Radius of the grain
    color c; // Color of the grain
    float noiseOffsetX, noiseOffsetY; // Offsets for Perlin noise
  
    Grain(float x, float y) {
      this.x = x;
      this.y = y;
      this.xSpeed = random(-1, 1);
      this.ySpeed = random(-1, 1);
      this.radius = random(2, 6);
      this.c = color(random(255), 255, 255, 150); // Random color with full saturation
      this.noiseOffsetX = random(1000); // Initialize Perlin noise offsets
      this.noiseOffsetY = random(1000);
    }
  
    void update() {
      // Use Perlin noise for smooth, natural movement
      float noiseX = map(noise(noiseOffsetX), 0, 1, -2, 2);
      float noiseY = map(noise(noiseOffsetY), 0, 1, -2, 2);
      
      // Update speed with Perlin noise
      xSpeed += noiseX;
      ySpeed += noiseY;
      
      // Move the grain
      x += xSpeed;
      y += ySpeed;
      
      // Bounce off the edges
      if (x < 0 || x > width) xSpeed *= -1;
      if (y < 0 || y > height) ySpeed *= -1;
      
      // Adjust speed and color based on mouse position
      float distToMouse = dist(mouseX, mouseY, x, y);
      float speedFactor = map(distToMouse, 0, width, 1, 0.5);
      xSpeed *= speedFactor;
      ySpeed *= speedFactor;
  
      // Update color based on proximity to mouse
      float colorHue = map(distToMouse, 0, width, 255, 0);
      c = color(colorHue, 255, 255, 150);
      
      // Update noise offsets for the next frame
      noiseOffsetX += 0.01;
      noiseOffsetY += 0.01;
    }
  
    void display() {
      fill(c);  
      ellipse(x, y, radius * 2, radius * 2);
    }
  }

</pre>
<h2>Terrain Designer</h2>
<pre>
  // Parameters for terrain
  int cols, rows;
  int w = 800, h = 800;
  float[][] terrain;
  float[][] originalTerrain;
  float scl = 20; // Scale factor for terrain height
  float baseHeight = 100; // Base height for terrain
  float mouseInfluence = 50; // Subtle effect of the mouse on terrain
  float returnSpeed = 0.1; // Speed at which the terrain returns to its original shape
  
  // Camera rotation angles
  float angleX = PI / 3; // Initial X-axis rotation
  float angleY = PI;     // Initial Y-axis rotation
  float angleSpeed = 0.05; // Speed of rotation
  
  void setup() {
    size(800, 800, P3D);
    cols = w / (int)scl;
    rows = h / (int)scl;
    terrain = new float[cols][rows];
    originalTerrain = new float[cols][rows];
    generateTerrain();
  }
  
  void draw() {
    background(135, 206, 235); // Sky color
    lights();
    translate(width/2, height/2);
    rotateX(angleX); // Rotate to view the terrain from an angle
    rotateY(angleY); // Rotate for better view
  
    // Update terrain based on mouse position
    updateTerrain();
  
    // Render terrain
    noFill();
    stroke(0);
    beginShape(TRIANGLES);
    for (int y = 0; y < rows-1; y++) {
      for (int x = 0; x < cols-1; x++) {
        float x0 = x * scl - w/2;
        float y0 = y * scl - h/2;
        float x1 = (x+1) * scl - w/2;
        float y1 = y * scl - h/2;
        float x2 = x * scl - w/2;
        float y2 = (y+1) * scl - h/2;
        float x3 = (x+1) * scl - w/2;
        float y3 = (y+1) * scl - h/2;
  
        vertex(x0, y0, terrain[x][y]);
        vertex(x1, y1, terrain[x+1][y]);
        vertex(x2, y2, terrain[x][y+1]);
  
        vertex(x1, y1, terrain[x+1][y]);
        vertex(x3, y3, terrain[x+1][y+1]);
        vertex(x2, y2, terrain[x][y+1]);
      }
    }
    endShape();
  }
  
  void generateTerrain() {
    // Generate a simple terrain with noise
    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        float height = map(noise(x * 0.1, y * 0.1), 0, 1, -baseHeight, baseHeight);
        terrain[x][y] = height;
        originalTerrain[x][y] = height; // Store original terrain
      }
    }
  }
  
  void updateTerrain() {
    // Temporary array to store updated terrain values
    float[][] updatedTerrain = new float[cols][rows];
    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        // Calculate distance from mouse position
        float dx = mouseX - (x * scl + width / 2);
        float dy = mouseY - (y * scl + height / 2);
        float distance = sqrt(dx * dx + dy * dy);
  
        // Subtle influence of mouse on terrain height
        float influence = constrain(map(distance, 0, width / 4, mouseInfluence, 0), 0, mouseInfluence);
        updatedTerrain[x][y] = terrain[x][y] + influence * 0.1; // Temporary deformation
  
        // Smoothly return terrain to its original height
        terrain[x][y] = lerp(terrain[x][y], updatedTerrain[x][y], returnSpeed);
      }
    }
    
    // Smoothly return terrain to its original shape over time
    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        if (dist(mouseX, mouseY, x * scl + width / 2, y * scl + height / 2) > width / 4) {
          terrain[x][y] = lerp(terrain[x][y], originalTerrain[x][y], returnSpeed);
        }
      }
    }
  }
  
  void keyPressed() {
    // Rotate based on key press
    if (key == 'w' || key == 'W') {
      angleX -= angleSpeed; // Rotate up
    }
    if (key == 's' || key == 'S') {
      angleX += angleSpeed; // Rotate down
    }
    if (key == 'a' || key == 'A') {
      angleY -= angleSpeed; // Rotate left
    }
    if (key == 'd' || key == 'D') {
      angleY += angleSpeed; // Rotate right
    }
  }
  </pre>

  <h2> Basic Lightning Animation</h2>
  <pre>
    int numBolts = 5;
    float[][] bolts = new float[numBolts][4]; // x1, y1, x2, y2
    
    void setup() {
      size(800, 600);
      background(0);
      stroke(255, 255, 0); // Yellow color for lightning
      strokeWeight(2);
    }
    
    void draw() {
      background(0);
      
      // Create and draw each bolt
      for (int i = 0; i < numBolts; i++) {
        if (random(1) < 0.1) { // 10% chance to regenerate bolt
          bolts[i][0] = random(width); // Start X
          bolts[i][1] = random(height / 2); // Start Y
          bolts[i][2] = random(width); // End X
          bolts[i][3] = random(height / 2, height); // End Y
        }
        drawBolt(bolts[i]);
      }
    }
    
    void drawBolt(float[] bolt) {
      // Draw zigzag lines for lightning effect
      float x1 = bolt[0];
      float y1 = bolt[1];
      float x2 = bolt[2];
      float y2 = bolt[3];
    
      // Create zigzag effect
      float segments = 10;
      float[][] points = new float[(int)segments + 1][2]; // Store points for zigzag
      for (int i = 0; i <= segments; i++) {
        float t = map(i, 0, segments, 0, 1);
        float x = lerp(x1, x2, t) + random(-10, 10); // Randomize X
        float y = lerp(y1, y2, t) + random(-10, 10); // Randomize Y
        points[i][0] = x;
        points[i][1] = y;
        
        // Draw lines
        if (i > 0) {
          line(points[i - 1][0], points[i - 1][1], x, y);
        }
      }
    }
  </pre>

<h2>Flickering Stars</h2>
<pre>
  int numStars = 200;
Star[] stars;

void setup() {
  size(800, 600);
  initializeStars(numStars);
}

void draw() {
  background(0);
  for (Star star : stars) {
    star.flicker();
    star.display();
  }
}

void initializeStars(int num) {
  stars = new Star[num];
  for (int i = 0; i < num; i++) {
    stars[i] = new Star(random(width), random(height));
  }
}

class Star {
  float x, y;
  float brightness;

  Star(float x, float y) {
    this.x = x;
    this.y = y;
    this.brightness = random(100, 255);
  }

  void flicker() {
    brightness = random(100, 255); // Random flickering brightness
  }

  void display() {
    stroke(255, brightness);
    strokeWeight(2);
    point(x, y);
  }
}
</pre>
<h2>Starfield Animation</h2>
<pre>
  int numStars = 1000;  // Set the number of stars in the flurry
  Star[] stars = new Star[numStars];  // Create an array to hold Star objects
  
  void setup() {
    size(1920, 1080);  // Set the window size to 800x600 pixels
    for (int i = 0; i < numStars; i++) {  // Initialize each star in the array
      stars[i] = new Star();  // Create a new Star object and store it in the array
    }
  }
  
  void draw() {
    background(0, 20, 50);  // Clear the screen with a black background in each frame
    for (int i = 0; i < stars.length; i++) {  // Loop through all the stars
      stars[i].move();  // Move each star
      stars[i].display();  // Display each star on the screen
    }
  }
  
  // Define a class called "Star"
  class Star {
    float x, y, z;  // Variables to hold the 3D position of the star
    float speed;  // Speed of the star's movement
    float size;  // Size of the star
    
    // Constructor to initialize a new star
    Star() {
      x = random(-width, width);  // Random x position between -width and +width
      y = random(-height, height);  // Random y position between -height and +height
      z = random(width);  // Random z position (distance from the viewer) from 0 to width
      speed = random(2, 5);  // Set a random speed for the star between 2 and 5
      size = random(2, 5);  // Set a random size for the star between 2 and 5
    }
  
    // Method to update the star's position
    void move() {
      z -= speed;  // Move the star forward (reduce z value)
      
      // If the star moves past the viewer (z < 1), reset it
      if (z < 1) {
        z = width;  // Reset z to the farthest point (width)
        x = random(-width, width);  // Re-randomize x position
        y = random(-height, height);  // Re-randomize y position
        speed = random(2, 5);  // Re-randomize the speed
        size = random(2, 5);  // Re-randomize the size
      }
    }
  
    // Method to draw the star on the screen
    void display() {
      // Calculate screen x position based on 3D depth (z)
      float sx = map(x / z, 0, 1, 0, width);  
      // Calculate screen y position based on 3D depth (z)
      float sy = map(y / z, 0, 1, 0, height);  
      // Map the star's size based on its depth (z); closer stars appear larger
      float r = map(z, 0, width, size, 0);  
  
      noStroke();  // Don't draw an outline around the stars
      fill(20, 250, 0);  // Set the color of the stars to white
      ellipse(sx, sy, r, r);  // Draw the star as a circle (ellipse) at position (sx, sy) with radius r
    }
  }
</pre>