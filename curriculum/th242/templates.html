---
layout: default
title: Templates
permalink: /curriculum/th242/templates
---
<main>
    <body>
        <h1>{{ page.title }}</h1>
<h2>Rainstorm animation</h2>
<pre>
    int numDrops = 100; // Number of raindrops
    Raindrop[] drops = new Raindrop[numDrops];
    
    void setup() {
      size(800, 600);
      background(0);
      
      // Initialize raindrops
      for (int i = 0; i < numDrops; i++) {
        drops[i] = new Raindrop(random(width), random(-height, 0));
      }
    }
    
    void draw() {
      background(0, 50); // Semi-transparent background to create a trail effect
      
      // Update and display each raindrop
      for (int i = 0; i < numDrops; i++) {
        drops[i].update();
        drops[i].display();
      }
    }
    
    // Raindrop class
    class Raindrop {
      float x, y;
      float speed;
      
      Raindrop(float x, float y) {
        this.x = x;
        this.y = y;
        this.speed = random(2, 5);
      }
      
      void update() {
        y += speed;
        // Reset drop to the top if it goes off screen
        if (y > height) {
          y = random(-50, -10);
          x = random(width);
          speed = random(2, 5);
        }
      }
      
      void display() {
        stroke(138, 43, 226); // Color of raindrop (blueish)
        strokeWeight(2);
        line(x, y, x, y + 10);
      }
    }
</pre>
<h2> Simple Sound Effect Player</h2>
<pre>
import ddf.minim.*; // Import the Minim library

Minim minim; // The Minim object
AudioPlayer player; // The audio player object

void setup() {
  size(400, 200);
  minim = new Minim(this); // Initialize Minim
  
  // Load the sound file (make sure the file is in the 'data' folder)
  player = minim.loadFile("sound.mp3"); // Change the file name if needed
  
  background(0); // Set background to black
  fill(255); // Set text color to white
  textAlign(CENTER, CENTER);
  textSize(20);
  text("Press any key to play sound", width / 2, height / 2);
}
</pre>

<h2>Interactive Gradient</h2>

<pre>
    void setup() {
        size(800, 600);
        noLoop(); // Prevent continuous redrawing
      }
      
      void draw() {
        // Map mouse position to gradient colors
        float red1 = map(mouseX, 0, width, 0, 255);
        float green1 = map(mouseY, 0, height, 0, 255);
        float blue1 = map(mouseX + mouseY, 0, width + height, 0, 255);
        
        float red2 = map(mouseX, 0, width, 255, 0);
        float green2 = map(mouseY, 0, height, 255, 0);
        float blue2 = map(mouseX + mouseY, 0, width + height, 255, 0);
      
        // Draw the gradient background
        for (int i = 0; i <= height; i++) {
          float inter = map(i, 0, height, 0, 1);
          float r = lerp(red1, red2, inter);
          float g = lerp(green1, green2, inter);
          float b = lerp(blue1, blue2, inter);
          stroke(r, g, b);
          line(0, i, width, i);
        }
      }
      
      void mouseMoved() {
        redraw(); // Redraw the background when the mouse is moved
      }
</pre>
<h2>Basic Synthesizer</h2>
<pre>
import processing.sound.*;  // Import the Sound library for audio functionality

SinOsc oscillator;  // Declare an instance of the SinOsc class for generating sine wave sounds
float frequency = 440; // Initial frequency for the sine wave (440 Hz corresponds to A4)

void setup() {
  size(600, 400);  // Set the size of the window to 600x400 pixels
  background(0);  // Set the background color to black
  oscillator = new SinOsc(this);  // Initialize the sine wave oscillator
  oscillator.play();  // Start playing the oscillator sound
  oscillator.freq(frequency);  // Set the initial frequency of the oscillator
}

void draw() {
  background(0);  // Continuously set the background color to black
  fill(255);  // Set the fill color to white
  textSize(32);  // Set the text size to 32 pixels
  text("Press keys 1-5 to change frequency", 10, height / 2);  // Display instructions in the center of the window
}

void keyPressed() {
  switch(key) {  // Check which key was pressed
    case '1': frequency = 261.63; // Set frequency to 261.63 Hz (C4) if '1' is pressed
      break;
    case '2': frequency = 293.66; // Set frequency to 293.66 Hz (D4) if '2' is pressed
      break;
    case '3': frequency = 329.63; // Set frequency to 329.63 Hz (E4) if '3' is pressed
      break;
    case '4': frequency = 349.23; // Set frequency to 349.23 Hz (F4) if '4' is pressed
      break;
    case '5': frequency = 392.00; // Set frequency to 392.00 Hz (G4) if '5' is pressed
      break;
    default: return;  // Do nothing if any key other than 1-5 is pressed
  }
  oscillator.freq(frequency);  // Update the oscillator frequency to the new value
}
    </pre>
<h2>Audio Chopper</h2>
    <pre>
import ddf.minim.*; // Import Minim library
import ddf.minim.ugens.*; // Import additional Minim classes for audio

Minim minim;
AudioPlayer player;
AudioSnippet[] snippets;
int numSnippets = 4; // Number of segments you want to chop the audio into
float snippetDuration; // Duration of each snippet in milliseconds

void setup() {
  size(400, 200);
  minim = new Minim(this);
  
  // Load an audio file
  player = minim.loadFile("your-audio-file.mp3");
  
  // Calculate snippet duration
  snippetDuration = player.length() / numSnippets;
  
  // Create snippets
  snippets = new AudioSnippet[numSnippets];
  for (int i = 0; i < numSnippets; i++) {
    float start = i * snippetDuration;
    float end = start + snippetDuration;
    snippets[i] = new AudioSnippet(player, start, end);
  }
  
  // Play snippets
  snippets[0].play(); // Play the first snippet as an example
}

void draw() {
  background(0);
  fill(255);
  text("Playing snippet 1", 10, 20);
}

// AudioSnippet class to handle chopping and playing segments
class AudioSnippet {
  AudioPlayer player;
  float start, end;
  
  AudioSnippet(AudioPlayer p, float s, float e) {
    player = p;
    start = s;
    end = e;
  }
  
  void play() {
    player.jump(start); // Move to start
    player.play();     // Play from start to end
    // To stop after snippet duration
    delay((int)(end - start));
    player.pause();
  }
  
  void stop() {
    player.pause();
  }
  
  void loop() {
    player.loop();
  }
}
    </pre>
    <h2>Interactive Audio Waveform Visualizer</h2>
    <div class="code-container">
      <button class="copy-btn" onclick="copyCode(this)">Copy</button>
    <pre>
      import ddf.minim.*; // Import Minim library

      Minim minim;
      AudioPlayer player;
      int bufferSize = 1024; // Size of the audio buffer
      float[] buffer; // Buffer to hold audio data
      
      void setup() {
        size(800, 400);
        minim = new Minim(this);
        
        // Load an audio file
        player = minim.loadFile("your-audio-file.mp3", bufferSize);
        player.loop(); // Start playing the audio
        
        buffer = new float[bufferSize]; // Initialize buffer
      }
      
      void draw() {
        background(0);
        stroke(255);
        noFill();
        
        // Update buffer with audio data
        player.mix.get(buffer);
      
        // Draw waveform
        float step = (float)width / buffer.length;
        beginShape();
        for (int i = 0; i < buffer.length; i++) {
          float x = i * step;
          float y = map(buffer[i], -1, 1, 0, height);
          vertex(x, y);
        }
        endShape();
        
        // Draw a circle where the mouse is
        fill(255, 0, 0);
        noStroke();
        ellipse(mouseX, mouseY, 20, 20);
        
        // Optionally, you can add effects or interactivity here
        // For example, adjust volume or apply filters based on mouse position
      }
      
      void stop() {
        player.close(); // Close the audio player when done
        minim.stop(); // Stop Minim
        super.stop();
      }
      </pre>

<h2> Interactive Field of Grains</h2>
<pre>
  int numGrains = 500; // Number of grains in the field
  Grain[] grains;
  
  void setup() {
    size(800, 600);
    noStroke();
    colorMode(HSB, 255); // Use HSB color mode for color variations
    
    // Initialize the grains
    grains = new Grain[numGrains];
    for (int i = 0; i < numGrains; i++) {
      grains[i] = new Grain(random(width), random(height));
    }
  }
  
  void draw() {
    background(0, 10); // Add a slight fade effect
    
    // Update and display each grain
    for (Grain grain : grains) {
      grain.update();
      grain.display();
    }
  }
  
  class Grain {
    float x, y; // Position of the grain
    float xSpeed, ySpeed; // Speed of the grain
    float radius; // Radius of the grain
    color c; // Color of the grain
    float noiseOffsetX, noiseOffsetY; // Offsets for Perlin noise
  
    Grain(float x, float y) {
      this.x = x;
      this.y = y;
      this.xSpeed = random(-1, 1);
      this.ySpeed = random(-1, 1);
      this.radius = random(2, 6);
      this.c = color(random(255), 255, 255, 150); // Random color with full saturation
      this.noiseOffsetX = random(1000); // Initialize Perlin noise offsets
      this.noiseOffsetY = random(1000);
    }
  
    void update() {
      // Use Perlin noise for smooth, natural movement
      float noiseX = map(noise(noiseOffsetX), 0, 1, -2, 2);
      float noiseY = map(noise(noiseOffsetY), 0, 1, -2, 2);
      
      // Update speed with Perlin noise
      xSpeed += noiseX;
      ySpeed += noiseY;
      
      // Move the grain
      x += xSpeed;
      y += ySpeed;
      
      // Bounce off the edges
      if (x < 0 || x > width) xSpeed *= -1;
      if (y < 0 || y > height) ySpeed *= -1;
      
      // Adjust speed and color based on mouse position
      float distToMouse = dist(mouseX, mouseY, x, y);
      float speedFactor = map(distToMouse, 0, width, 1, 0.5);
      xSpeed *= speedFactor;
      ySpeed *= speedFactor;
  
      // Update color based on proximity to mouse
      float colorHue = map(distToMouse, 0, width, 255, 0);
      c = color(colorHue, 255, 255, 150);
      
      // Update noise offsets for the next frame
      noiseOffsetX += 0.01;
      noiseOffsetY += 0.01;
    }
  
    void display() {
      fill(c);
      ellipse(x, y, radius * 2, radius * 2);
    }
  }

</pre>
<h2>Terrain Designer</h2>
<pre>
  // Parameters for terrain
  int cols, rows;
  int w = 800, h = 800;
  float[][] terrain;
  float[][] originalTerrain;
  float scl = 20; // Scale factor for terrain height
  float baseHeight = 100; // Base height for terrain
  float mouseInfluence = 50; // Subtle effect of the mouse on terrain
  float returnSpeed = 0.1; // Speed at which the terrain returns to its original shape
  
  // Camera rotation angles
  float angleX = PI / 3; // Initial X-axis rotation
  float angleY = PI;     // Initial Y-axis rotation
  float angleSpeed = 0.05; // Speed of rotation
  
  void setup() {
    size(800, 800, P3D);
    cols = w / (int)scl;
    rows = h / (int)scl;
    terrain = new float[cols][rows];
    originalTerrain = new float[cols][rows];
    generateTerrain();
  }
  
  void draw() {
    background(135, 206, 235); // Sky color
    lights();
    translate(width/2, height/2);
    rotateX(angleX); // Rotate to view the terrain from an angle
    rotateY(angleY); // Rotate for better view
  
    // Update terrain based on mouse position
    updateTerrain();
  
    // Render terrain
    noFill();
    stroke(0);
    beginShape(TRIANGLES);
    for (int y = 0; y < rows-1; y++) {
      for (int x = 0; x < cols-1; x++) {
        float x0 = x * scl - w/2;
        float y0 = y * scl - h/2;
        float x1 = (x+1) * scl - w/2;
        float y1 = y * scl - h/2;
        float x2 = x * scl - w/2;
        float y2 = (y+1) * scl - h/2;
        float x3 = (x+1) * scl - w/2;
        float y3 = (y+1) * scl - h/2;
  
        vertex(x0, y0, terrain[x][y]);
        vertex(x1, y1, terrain[x+1][y]);
        vertex(x2, y2, terrain[x][y+1]);
  
        vertex(x1, y1, terrain[x+1][y]);
        vertex(x3, y3, terrain[x+1][y+1]);
        vertex(x2, y2, terrain[x][y+1]);
      }
    }
    endShape();
  }
  
  void generateTerrain() {
    // Generate a simple terrain with noise
    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        float height = map(noise(x * 0.1, y * 0.1), 0, 1, -baseHeight, baseHeight);
        terrain[x][y] = height;
        originalTerrain[x][y] = height; // Store original terrain
      }
    }
  }
  
  void updateTerrain() {
    // Temporary array to store updated terrain values
    float[][] updatedTerrain = new float[cols][rows];
    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        // Calculate distance from mouse position
        float dx = mouseX - (x * scl + width / 2);
        float dy = mouseY - (y * scl + height / 2);
        float distance = sqrt(dx * dx + dy * dy);
  
        // Subtle influence of mouse on terrain height
        float influence = constrain(map(distance, 0, width / 4, mouseInfluence, 0), 0, mouseInfluence);
        updatedTerrain[x][y] = terrain[x][y] + influence * 0.1; // Temporary deformation
  
        // Smoothly return terrain to its original height
        terrain[x][y] = lerp(terrain[x][y], updatedTerrain[x][y], returnSpeed);
      }
    }
    
    // Smoothly return terrain to its original shape over time
    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        if (dist(mouseX, mouseY, x * scl + width / 2, y * scl + height / 2) > width / 4) {
          terrain[x][y] = lerp(terrain[x][y], originalTerrain[x][y], returnSpeed);
        }
      }
    }
  }
  
  void keyPressed() {
    // Rotate based on key press
    if (key == 'w' || key == 'W') {
      angleX -= angleSpeed; // Rotate up
    }
    if (key == 's' || key == 'S') {
      angleX += angleSpeed; // Rotate down
    }
    if (key == 'a' || key == 'A') {
      angleY -= angleSpeed; // Rotate left
    }
    if (key == 'd' || key == 'D') {
      angleY += angleSpeed; // Rotate right
    }
  }
  </pre>
