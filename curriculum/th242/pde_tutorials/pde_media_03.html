---
layout: default
title: media design 3
permalink: /curriculum/th242/pde_tutorials/pde_media_03/
---
<h1>Processing Tutorial Series 3</h1>

    <section id="tutorial-1">
        <h2>Tutorial 1: Advanced Animation Techniques</h2>
        <p><strong>Objective:</strong> Explore more complex animation techniques and create smoother animations.</p>
        <h3>1. Using Frame Rate</h3>
        <pre><code>
float x = 0;
float speed = 2;

void setup() {
    size(800, 600);
    frameRate(60); // Set frame rate to 60 frames per second
}

void draw() {
    background(255);
    fill(0, 100, 255);
    ellipse(x, height / 2, 50, 50);
    x += speed; // Update x position
    if (x > width) {
        x = 0; // Reset x to 0 if it goes off-screen
    }
}
        </code></pre>
        <p><strong>Explanation:</strong></p>
        <ul>
            <li><code>frameRate(60)</code>: Sets the number of frames per second, allowing for smoother animations.</li>
            <li><code>float speed = 2</code>: Defines the speed of the animation.</li>
        </ul>
        <p>Using the <code>frameRate</code> function helps create more fluid and visually appealing animations.</p>
    </section>

    <section id="tutorial-2">
        <h2>Tutorial 2: Working with PImages</h2>
        <p><strong>Objective:</strong> Learn how to load, display, and manipulate images in Processing.</p>
        <h3>1. Loading and Displaying Images</h3>
        <pre><code>
PImage img;

void setup() {
    size(800, 600);
    img = loadImage("example.jpg"); // Load an image file
}

void draw() {
    background(255);
    image(img, 0, 0); // Display the image at position (0, 0)
}
        </code></pre>
        <p><strong>Explanation:</strong></p>
        <ul>
            <li><code>PImage img</code>: Declares a variable to hold the image.</li>
            <li><code>loadImage("example.jpg")</code>: Loads the image file into the variable.</li>
            <li><code>image(img, 0, 0)</code>: Displays the image at the specified coordinates.</li>
        </ul>
        <p>Working with images opens up many possibilities for incorporating graphics into your sketches.</p>
    </section>

    <section id="tutorial-3">
        <h2>Tutorial 3: Creating Interactive Visualizations</h2>
        <p><strong>Objective:</strong> Build interactive visualizations that respond to user inputs.</p>
        <h3>1. Interactive Particle System</h3>
        <pre><code>
class Particle {
    float x, y;
    float speedX, speedY;
    color c;

    Particle(float x, float y, float speedX, float speedY, color c) {
        this.x = x;
        this.y = y;
        this.speedX = speedX;
        this.speedY = speedY;
        this.c = c;
    }

    void update() {
        x += speedX;
        y += speedY;
        if (x > width || x < 0) speedX *= -1;
        if (y > height || y < 0) speedY *= -1;
    }

    void display() {
        fill(c);
        ellipse(x, y, 10, 10);
    }
}

ArrayList<Particle> particles;

void setup() {
    size(800, 600);
    particles = new ArrayList<Particle>();
    for (int i = 0; i < 100; i++) {
        particles.add(new Particle(random(width), random(height), random(-2, 2), random(-2, 2), color(random(255), random(255), random(255))));
    }
}

void draw() {
    background(255);
    for (Particle p : particles) {
        p.update();
        p.display();
    }
}
        </code></pre>
        <p><strong>Explanation:</strong></p>
        <ul>
            <li><code>class Particle</code>: Defines a class to represent each particle with properties and methods.</li>
            <li><code>ArrayList<Particle> particles</code>: Creates an array list to hold multiple particles.</li>
            <li><code>for (Particle p : particles)</code>: Iterates through each particle to update and display it.</li>
        </ul>
        <p>Interactive visualizations can be created by combining classes and user interactions to generate dynamic visual effects.</p>
    </section>

    <section id="tutorial-4">
        <h2>Tutorial 4: Using 3D Graphics</h2>
        <p><strong>Objective:</strong> Explore 3D graphics and create 3D shapes and interactions.</p>
        <h3>1. Creating and Manipulating 3D Shapes</h3>
        <pre><code>
void setup() {
    size(800, 600, P3D);
}

void draw() {
    background(200);
    translate(width / 2, height / 2); // Move origin to center of window
    rotateX(frameCount * 0.01);
    rotateY(frameCount * 0.01);
    fill(150, 0, 255);
    box(200); // Draw a rotating 3D box
}
        </code></pre>
        <p><strong>Explanation:</strong></p>
        <ul>
            <li><code>size(800, 600, P3D)</code>: Sets up a 3D renderer.</li>
            <li><code>translate(width / 2, height / 2)</code>: Moves the origin to the center of the window.</li>
            <li><code>rotateX(frameCount * 0.01)</code>: Rotates the box along the X-axis over time.</li>
            <li><code>box(200)</code>: Draws a 3D box with a specified size.</li>
        </ul>
        <p>Working with 3D graphics adds depth and complexity to your visual projects.</p>
    </section>

    <section id="tutorial-5">
        <h2>Tutorial 5: Implementing Perlin Noise</h2>
        <p><strong>Objective:</strong> Use Perlin noise to create natural-looking randomness and smooth transitions.</p>
        <h3>1. Generating Noise-Based Patterns</h3>
        <pre><code>
float noiseX = 0;

void setup() {
    size(800, 600);
}

void draw() {
    background(255);
    float x = noise(noiseX) * width;
    float y = noise(noiseX + 100) * height;
    fill(0, 100, 255);
    ellipse(x, y, 50, 50);
    noiseX += 0.01;
}
        </code></pre>
        <p><strong>Explanation:</strong></p>
        <ul>
            <li><code>noise(noiseX)</code>: Generates Perlin noise values for smooth randomness.</li>
            <li><code>noiseX += 0.01</code>: Updates the noise input to create continuous movement.</li>
        </ul>
        <p>Perlin noise can be used to create more organic and less chaotic randomness compared to traditional random functions.</p>
    </section>

    <section id="tutorial-6">
        <h2>Tutorial 6: Working with Audio</h2>
        <p><strong>Objective:</strong> Integrate audio into your Processing sketches to create sound-driven visuals.</p>
        <h3>1. Playing Sound Files</h3>
        <pre><code>
import processing.sound.*;

SoundFile sound;

void setup() {
    size(800, 600);
    sound = new SoundFile(this, "example.mp3");
    sound.play(); // Play the sound file
}

void draw() {
    background(255);
    // Visualization or interaction with audio goes here
}
        </code></pre>
        <p><strong>Explanation:</strong></p>
        <ul>
            <li><code>import processing.sound.*</code>: Imports the Sound library for audio functionality.</li>
            <li><code>SoundFile sound</code>: Declares a variable for the sound file.</li>
            <li><code>sound.play()</code>: Plays the sound file.</li>
        </ul>
        <p>Incorporating audio can enhance your sketches and create interactive audio-visual experiences.</p>
    </section>

    <section id="tutorial-7">
        <h2>Tutorial 7: Creating Custom Shapes</h2>
        <p><strong>Objective:</strong> Learn how to create and draw custom shapes using vertex manipulation.</p>
        <h3>1. Drawing Custom Shapes</h3>
        <pre><code>
void setup() {
    size(800, 600);
    background(255);
}

void draw() {
    background(255);
    fill(0, 100, 255);
    beginShape();
    vertex(100, 100);
    vertex(200, 50);
    vertex(300, 100);
    vertex(250, 200);
    vertex(150, 200);
    endShape(CLOSE); // Draw a custom pentagon shape
}
        </code></pre>
        <p><strong>Explanation:</strong></p>
        <ul>
            <li><code>beginShape()</code>: Starts defining a custom shape.</li>
            <li><code>vertex(x, y)</code>: Specifies points for the shape.</li>
            <li><code>endShape(CLOSE)</code>: Completes the shape and closes it.</li>
        </ul>
        <p>Creating custom shapes allows for more artistic and unique visuals in your sketches.</p>
    </section>

    <section id="tutorial-8">
        <h2>Tutorial 8: Implementing Algorithms</h2>
        <p><strong>Objective:</strong> Use common algorithms to create interesting visual effects.</p>
        <h3>1. Implementing the Mandelbrot Set</h3>
        <pre><code>
int maxIterations = 100;

void setup() {
    size(800, 600);
}

void draw() {
    loadPixels();
    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            float cRe = map(x, 0, width, -2.5, 1);
            float cIm = map(y, 0, height, -1, 1);
            float zRe = cRe, zIm = cIm;
            int n;
            for (n = 0; n < maxIterations; n++) {
                float zRe2 = zRe * zRe;
                float zIm2 = zIm * zIm;
                if (zRe2 + zIm2 > 4) break;
                zIm = 2 * zRe * zIm + cIm;
                zRe = zRe2 - zIm2 + cRe;
            }
            int colorValue = map(n, 0, maxIterations, 0, 255);
            pixels[x + y * width] = color(colorValue);
        }
    }
    updatePixels();
}
        </code></pre>
        <p><strong>Explanation:</strong></p>
        <ul>
            <li><code>map(x, 0, width, -2.5, 1)</code>: Maps pixel positions to complex plane coordinates.</li>
            <li><code>maxIterations</code>: Defines the maximum number of iterations for the algorithm.</li>
        </ul>
        <p>Implementing algorithms like the Mandelbrot set can produce intricate and visually stunning patterns.</p>
    </section>

    <section id="tutorial-9">
        <h2>Tutorial 9: Building Games</h2>
        <p><strong>Objective:</strong> Learn the basics of game development using Processing.</p>
        <h3>1. Simple Game Example: Avoid the Falling Blocks</h3>
        <pre><code>
int playerX, playerY;
int blockX, blockY;
int blockSpeed = 5;

void setup() {
    size(800, 600);
    playerX = width / 2;
    playerY = height - 50;
    blockX = int(random(width));
    blockY = 0;
}

void draw() {
    background(255);
    fill(0, 100, 255);
    rect(playerX, playerY, 50, 20); // Draw the player
    
    blockY += blockSpeed; // Move the block downwards
    fill(255, 0, 0);
    rect(blockX, blockY, 30, 30); // Draw the falling block
    
    if (blockY > height) {
        blockY = 0;
        blockX = int(random(width));
    }
    
    if (keyPressed) {
        if (keyCode == LEFT) {
            playerX -= 5;
        } else if (keyCode == RIGHT) {
            playerX += 5;
        }
    }
    
    if (playerX < 0) playerX = 0;
    if (playerX > width - 50) playerX = width - 50;
}
        </code></pre>
        <p><strong>Explanation:</strong></p>
        <ul>
            <li><code>rect(playerX, playerY, 50, 20)</code>: Draws the player character.</li>
            <li><code>blockY += blockSpeed</code>: Updates the block's position to simulate falling.</li>
            <li><code>keyPressed</code>: Checks for keyboard input to move the player.</li>
        </ul>
        <p>Building games involves managing game logic, user input, and rendering graphics to create interactive experiences.</p>
    </section>

    <section id="tutorial-10">
        <h2>Tutorial 10: Exporting and Sharing Your Work</h2>
        <p><strong>Objective:</strong> Learn how to export your Processing sketches and share them with others.</p>
        <h3>1. Exporting Your Sketch</h3>
        <pre><code>
void setup() {
    size(800, 600);
}

void draw() {
    background(255);
    fill(0, 100, 255);
    ellipse(width / 2, height / 2, 100, 100);
}

void keyPressed() {
    if (key == 's') {
        saveFrame("mySketch-####.png"); // Save the current frame as a PNG file
    }
}
        </code></pre>
        <p><strong>Explanation:</strong></p>
        <ul>
            <li><code>saveFrame("mySketch-####.png")</code>: Saves the current frame as an image file, with automatic numbering.</li>
            <li><code>keyPressed()</code>: Detects when a key is pressed and triggers the save function.</li>
        </ul>
        <p>Exporting your sketches allows you to share your work with others or use it in different contexts.</p>
    </section>
</body>
</html>
